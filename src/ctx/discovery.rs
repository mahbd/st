//! Discovery module for auto-tracking branches from GitHub PRs.
//!
//! This module provides functionality to discover and track branches that were
//! previously created with `st` on another machine by examining GitHub PRs.

use crate::{
    config::StConfig,
    errors::{StError, StResult},
    tree::{RemoteMetadata, StackTree},
};
use git2::{BranchType, Repository};
use nu_ansi_term::Color;
use octocrab::Octocrab;

/// Signature that identifies PRs created by `st`.
const ST_SIGNATURE: &str = "This comment was automatically generated by [`st`]";

/// Checks if a PR has the st signature in its comments.
async fn check_for_st_signature(
    gh_client: &Octocrab,
    owner: &str,
    repo: &str,
    pr_number: u64,
) -> bool {
    // First check PR body
    if let Ok(pr) = gh_client.pulls(owner, repo).get(pr_number).await {
        if let Some(body) = pr.body {
            if body.contains(ST_SIGNATURE) {
                return true;
            }
        }
    }

    // Then check comments
    if let Ok(comments) = gh_client
        .issues(owner, repo)
        .list_comments(pr_number)
        .send()
        .await
    {
        for comment in comments.items {
            if let Some(body) = comment.body {
                if body.contains(ST_SIGNATURE) {
                    return true;
                }
            }
        }
    }

    false
}

/// Fetches a branch from origin and creates a local tracking branch.
fn fetch_and_create_local_branch(branch_name: &str) -> StResult<()> {
    // Fetch the branch from origin
    let output = std::process::Command::new("git")
        .args(["fetch", "origin", branch_name])
        .output()?;

    if !output.status.success() {
        return Err(StError::DecodingError(format!(
            "Failed to fetch branch: {}",
            String::from_utf8_lossy(&output.stderr)
        )));
    }

    // Create local branch from remote
    let output = std::process::Command::new("git")
        .args([
            "branch",
            "--track",
            branch_name,
            &format!("origin/{}", branch_name),
        ])
        .output()?;

    if !output.status.success() {
        // Branch might already exist, try to set upstream
        let output = std::process::Command::new("git")
            .args([
                "branch",
                "--set-upstream-to",
                &format!("origin/{}", branch_name),
                branch_name,
            ])
            .output()?;

        if !output.status.success() {
            return Err(StError::DecodingError(format!(
                "Failed to create local branch: {}",
                String::from_utf8_lossy(&output.stderr)
            )));
        }
    }

    Ok(())
}

/// Parses the GitHub owner and repository from the remote URL.
fn parse_owner_and_repo(repo: &Repository) -> StResult<(String, String)> {
    let remote = repo.find_remote("origin")?;
    let url = remote
        .url()
        .ok_or(StError::RemoteNotFound("origin".to_string()))?;

    let (org, repo_name) = if url.starts_with("git@") {
        // Handle SSH URL: git@github.com:org/repo.git
        let parts = url.split(':').collect::<Vec<_>>();
        let repo_parts = parts
            .get(1)
            .ok_or(StError::DecodingError(
                "Invalid SSH URL format.".to_string(),
            ))?
            .split('/')
            .collect::<Vec<_>>();
        let org = repo_parts.first().ok_or(StError::DecodingError(
            "Organization not found.".to_string(),
        ))?;
        let repo_name = repo_parts.get(1).ok_or(StError::DecodingError(
            "Repository not found while decoding remote URL.".to_string(),
        ))?;
        (
            org.to_string(),
            repo_name.trim_end_matches(".git").to_string(),
        )
    } else if url.starts_with("https://") {
        // Handle HTTPS URL: https://github.com/org/repo.git
        let parts = url.split('/').collect::<Vec<_>>();
        let org = parts.get(parts.len() - 2).ok_or(StError::DecodingError(
            "Organization not found.".to_string(),
        ))?;
        let repo_name = parts.last().ok_or(StError::DecodingError(
            "Repository not found while decoding remote URL.".to_string(),
        ))?;
        (
            org.to_string(),
            repo_name.trim_end_matches(".git").to_string(),
        )
    } else {
        return Err(StError::DecodingError(
            "Unsupported remote URL format.".to_string(),
        ));
    };

    Ok((org, repo_name))
}

/// Attempts to discover and track branches from GitHub for an existing context.
/// This is useful when new branches were created on another machine.
///
/// ## Takes
/// - `config` - The st configuration
/// - `repo` - The git repository
/// - `existing_tree` - The existing stack tree to add discovered branches to
///
/// ## Returns
/// - `Result<usize>` - The number of newly discovered branches
pub async fn sync_discovered_branches(
    config: &StConfig,
    repo: &Repository,
    existing_tree: &mut StackTree,
) -> StResult<usize> {
    let (owner, repo_name) = parse_owner_and_repo(repo)?;
    let trunk_name = existing_tree.trunk_name().to_string();

    let gh_client = Octocrab::builder()
        .personal_token(config.github_token.clone())
        .build()?;

    // Fetch all open PRs
    let pulls = gh_client.pulls(&owner, &repo_name);
    let open_prs = pulls
        .list()
        .state(octocrab::params::State::Open)
        .per_page(100)
        .send()
        .await?;

    let mut new_branches = 0;

    for pr in open_prs.items {
        let head_branch = pr.head.ref_field.clone();
        let base_branch = pr.base.ref_field.clone();

        // Skip if already tracked
        if existing_tree.get(&head_branch).is_some() {
            continue;
        }

        // Check if this is an st PR
        let is_st_pr = check_for_st_signature(&gh_client, &owner, &repo_name, pr.number).await;
        if !is_st_pr {
            continue;
        }

        // Check if parent is tracked or is trunk
        let parent_tracked =
            base_branch == trunk_name || existing_tree.get(&base_branch).is_some();
        if !parent_tracked {
            continue;
        }

        // Check if branch exists locally, if not try to fetch
        let branch_exists_locally = repo.find_branch(&head_branch, BranchType::Local).is_ok();
        if !branch_exists_locally {
            // Try to fetch it
            if fetch_and_create_local_branch(&head_branch).is_err() {
                continue;
            }
        }

        // Get parent OID
        let parent_oid = repo
            .find_branch(&base_branch, BranchType::Local)
            .ok()
            .and_then(|b| b.get().target())
            .map(|oid| oid.to_string())
            .unwrap_or_default();

        // Insert the branch
        if existing_tree
            .insert(&base_branch, &parent_oid, &head_branch)
            .is_ok()
        {
            // Set remote metadata
            if let Some(tracked) = existing_tree.get_mut(&head_branch) {
                tracked.remote = Some(RemoteMetadata::new(pr.number));
            }

            println!(
                "  âœ“ Discovered and tracked: {} -> {}",
                Color::Green.paint(&head_branch),
                Color::Yellow.paint(&base_branch)
            );
            new_branches += 1;
        }
    }

    Ok(new_branches)
}