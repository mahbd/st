//! Discovery module for auto-tracking branches from GitHub PRs.
//!
//! This module provides functionality to discover and track branches that were
//! previously created with `st` on another machine by examining GitHub PRs.

use crate::{
    config::StConfig,
    errors::{StError, StResult},
    tree::{RemoteMetadata, StackTree},
};
use git2::{BranchType, Repository};
use inquire::Confirm;
use nu_ansi_term::Color;
use octocrab::Octocrab;
use std::collections::{HashMap, HashSet};

/// Signature that identifies PRs created by `st`.
const ST_SIGNATURE: &str = "This comment was automatically generated by [`st`]";

/// Information about a discovered PR.
#[derive(Debug, Clone)]
struct DiscoveredPr {
    /// PR number
    number: u64,
    /// Head branch name (the branch this PR is for)
    head_branch: String,
    /// Base branch name (the parent branch)
    base_branch: String,
    /// PR title
    title: String,
    /// Whether this PR was created by st (has st signature)
    is_st_pr: bool,
}

/// Checks if a PR has the st signature in its comments.
async fn check_for_st_signature(
    gh_client: &Octocrab,
    owner: &str,
    repo: &str,
    pr_number: u64,
) -> bool {
    // Check comments
    if let Ok(comments) = gh_client
        .issues(owner, repo)
        .list_comments(pr_number)
        .send()
        .await
    {
        for comment in comments.items {
            if let Some(body) = comment.body {
                if body.contains(ST_SIGNATURE) {
                    return true;
                }
            }
        }
    }

    false
}

/// Fetches a branch from origin and creates a local tracking branch.
fn fetch_and_create_local_branch(branch_name: &str) -> StResult<()> {
    // Fetch the branch from origin
    let output = std::process::Command::new("git")
        .args(["fetch", "origin", branch_name])
        .output()?;

    if !output.status.success() {
        return Err(StError::DecodingError(format!(
            "Failed to fetch branch: {}",
            String::from_utf8_lossy(&output.stderr)
        )));
    }

    // Create local branch from remote
    let output = std::process::Command::new("git")
        .args([
            "branch",
            "--track",
            branch_name,
            &format!("origin/{}", branch_name),
        ])
        .output()?;

    if !output.status.success() {
        // Branch might already exist, try to set upstream
        let output = std::process::Command::new("git")
            .args([
                "branch",
                "--set-upstream-to",
                &format!("origin/{}", branch_name),
                branch_name,
            ])
            .output()?;

        if !output.status.success() {
            return Err(StError::DecodingError(format!(
                "Failed to create local branch: {}",
                String::from_utf8_lossy(&output.stderr)
            )));
        }
    }

    Ok(())
}

/// Parses the GitHub owner and repository from the remote URL.
fn parse_owner_and_repo(repo: &Repository) -> StResult<(String, String)> {
    let remote = repo.find_remote("origin")?;
    let url = remote
        .url()
        .ok_or(StError::RemoteNotFound("origin".to_string()))?;

    let (org, repo_name) = if url.starts_with("git@") {
        // Handle SSH URL: git@github.com:org/repo.git
        let parts = url.split(':').collect::<Vec<_>>();
        let repo_parts = parts
            .get(1)
            .ok_or(StError::DecodingError(
                "Invalid SSH URL format.".to_string(),
            ))?
            .split('/')
            .collect::<Vec<_>>();
        let org = repo_parts.first().ok_or(StError::DecodingError(
            "Organization not found.".to_string(),
        ))?;
        let repo_name = repo_parts.get(1).ok_or(StError::DecodingError(
            "Repository not found while decoding remote URL.".to_string(),
        ))?;
        (
            org.to_string(),
            repo_name.trim_end_matches(".git").to_string(),
        )
    } else if url.starts_with("https://") {
        // Handle HTTPS URL: https://github.com/org/repo.git
        let parts = url.split('/').collect::<Vec<_>>();
        let org = parts.get(parts.len() - 2).ok_or(StError::DecodingError(
            "Organization not found.".to_string(),
        ))?;
        let repo_name = parts.last().ok_or(StError::DecodingError(
            "Repository not found while decoding remote URL.".to_string(),
        ))?;
        (
            org.to_string(),
            repo_name.trim_end_matches(".git").to_string(),
        )
    } else {
        return Err(StError::DecodingError(
            "Unsupported remote URL format.".to_string(),
        ));
    };

    Ok((org, repo_name))
}

/// Builds a map of branch name to the PRs that depend on it (children).
fn build_dependency_graph(prs: &[DiscoveredPr]) -> HashMap<String, Vec<String>> {
    let mut graph: HashMap<String, Vec<String>> = HashMap::new();

    for pr in prs {
        graph
            .entry(pr.base_branch.clone())
            .or_default()
            .push(pr.head_branch.clone());
    }

    graph
}

/// Gets all ancestors of a branch that need to be tracked (excluding trunk and already tracked).
/// Uses all_prs_by_head which includes both st and non-st PRs to find the complete chain.
fn get_required_ancestors(
    branch: &str,
    all_prs_by_head: &HashMap<String, &DiscoveredPr>,
    trunk_name: &str,
    already_tracked: &HashSet<String>,
) -> Vec<String> {
    let mut ancestors = Vec::new();
    let mut current = branch.to_string();

    while let Some(pr) = all_prs_by_head.get(&current) {
        let parent = &pr.base_branch;

        // Stop if we hit trunk or an already tracked branch - this is a valid anchor
        if parent == trunk_name || already_tracked.contains(parent) {
            break;
        }

        // Add parent to ancestors if it's any PR (st or non-st)
        if all_prs_by_head.contains_key(parent) {
            ancestors.push(parent.clone());
        } else {
            // Parent is not any PR and not tracked - chain is broken
            // Return empty vec to signal that tracking is not possible
            return Vec::new();
        }

        current = parent.clone();
    }

    // Reverse so ancestors are in order from root to immediate parent
    ancestors.reverse();
    ancestors
}

/// Attempts to discover and track branches from GitHub for an existing context.
/// This is useful when new branches were created on another machine.
///
/// For each discovered PR, asks the user if they want to track it.
/// Handles parent dependencies - if a branch's parent is not tracked,
/// offers to track the parent first.
///
/// ## Takes
/// - `config` - The st configuration
/// - `repo` - The git repository
/// - `existing_tree` - The existing stack tree to add discovered branches to
///
/// ## Returns
/// - `Result<usize>` - The number of newly discovered branches
pub async fn sync_discovered_branches(
    config: &StConfig,
    repo: &Repository,
    existing_tree: &mut StackTree,
) -> StResult<usize> {
    let (owner, repo_name) = parse_owner_and_repo(repo)?;
    let trunk_name = existing_tree.trunk_name().to_string();

    let gh_client = Octocrab::builder()
        .personal_token(config.github_token.clone())
        .build()?;

    println!("üîç Scanning for st PRs...\n");

    // Fetch all open PRs
    let pulls = gh_client.pulls(&owner, &repo_name);
    let open_prs = pulls
        .list()
        .state(octocrab::params::State::Open)
        .per_page(100)
        .send()
        .await?;

    // First pass: collect ALL PRs (both st and non-st) for parent relationship tracking
    let mut all_prs: Vec<DiscoveredPr> = Vec::new();
    let mut st_pr_branches: HashSet<String> = HashSet::new();

    for pr in open_prs.items {
        let head_branch = pr.head.ref_field.clone();

        // Skip if already tracked
        if existing_tree.get(&head_branch).is_some() {
            continue;
        }

        // Check if this is an st PR
        let is_st_pr = check_for_st_signature(&gh_client, &owner, &repo_name, pr.number).await;
        if is_st_pr {
            st_pr_branches.insert(head_branch.clone());
        }

        let title = pr.title.clone().unwrap_or_else(|| "(no title)".to_string());
        all_prs.push(DiscoveredPr {
            number: pr.number,
            head_branch,
            base_branch: pr.base.ref_field.clone(),
            title,
            is_st_pr,
        });
    }

    // Filter to just st PRs for display purposes
    let discovered_prs: Vec<&DiscoveredPr> = all_prs
        .iter()
        .filter(|pr| pr.is_st_pr)
        .collect();

    if discovered_prs.is_empty() {
        println!("No new st PRs found to track.");
        return Ok(0);
    }

    println!(
        "Found {} st PR(s) not currently tracked:\n",
        discovered_prs.len()
    );

    // Build lookup maps - all_prs_by_head includes both st and non-st PRs
    let all_prs_by_head: HashMap<String, &DiscoveredPr> = all_prs
        .iter()
        .map(|pr| (pr.head_branch.clone(), pr))
        .collect();

    let _dependency_graph = build_dependency_graph(&all_prs);

    // Track which branches the user has decided to track
    let mut to_track: HashSet<String> = HashSet::new();
    let mut skipped: HashSet<String> = HashSet::new();

    // Already tracked branches (including trunk)
    let mut already_tracked: HashSet<String> = HashSet::new();
    already_tracked.insert(trunk_name.clone());
    if let Ok(branches) = existing_tree.branches() {
        for branch in branches {
            already_tracked.insert(branch);
        }
    }

    // Process each discovered PR
    for pr in discovered_prs.iter() {
        // Skip if already decided to track (as a dependency)
        if to_track.contains(&pr.head_branch) {
            continue;
        }

        // Skip if user already skipped this
        if skipped.contains(&pr.head_branch) {
            continue;
        }

        println!(
            "{}",
            Color::Cyan.paint(format!(
                "PR #{}: {} ({})",
                pr.number, pr.title, pr.head_branch
            ))
        );
        println!(
            "  Base: {}",
            Color::Yellow.paint(&pr.base_branch)
        );

        // Check if parent is tracked or will be tracked
        let parent_available = pr.base_branch == trunk_name
            || already_tracked.contains(&pr.base_branch)
            || to_track.contains(&pr.base_branch);

        if !parent_available {
            // Check if parent is any PR (st or non-st) - we can follow the chain
            if all_prs_by_head.contains_key(&pr.base_branch) {
                // Get all required ancestors (may include non-st PRs)
                let ancestors = get_required_ancestors(
                    &pr.head_branch,
                    &all_prs_by_head,
                    &trunk_name,
                    &already_tracked,
                );

                if ancestors.is_empty() {
                    // Parent exists but its parent chain is broken
                    println!(
                        "  {} Parent branch '{}' has untrackable ancestors (no PR or trunk found).",
                        Color::Red.paint("‚ö†"),
                        pr.base_branch
                    );
                    println!("  Skipping this PR.\n");
                    skipped.insert(pr.head_branch.clone());
                    continue;
                }

                // Check if any ancestor was skipped
                let any_ancestor_skipped = ancestors.iter().any(|a| skipped.contains(a));
                if any_ancestor_skipped {
                    println!(
                        "  {} Cannot track: a required parent was skipped.",
                        Color::Red.paint("‚ö†")
                    );
                    println!("  Skipping this PR.\n");
                    skipped.insert(pr.head_branch.clone());
                    continue;
                }

                // Ask about tracking with dependencies
                let ancestor_names: Vec<&str> = ancestors.iter().map(|s| s.as_str()).collect();
                println!(
                    "  {} To track this branch, the following parent(s) must also be tracked:",
                    Color::Yellow.paint("!")
                );
                for ancestor in &ancestor_names {
                    if let Some(ancestor_pr) = all_prs_by_head.get(*ancestor) {
                        if ancestor_pr.is_st_pr {
                            println!(
                                "    - {} (PR #{})",
                                Color::Green.paint(*ancestor),
                                ancestor_pr.number
                            );
                        } else {
                            println!(
                                "    - {} (PR #{}, not an st PR)",
                                Color::Yellow.paint(*ancestor),
                                ancestor_pr.number
                            );
                        }
                    }
                }

                let confirm = Confirm::new(&format!(
                    "Track '{}' and its {} required parent(s)?",
                    pr.head_branch,
                    ancestors.len()
                ))
                .with_default(true)
                .prompt()?;

                if confirm {
                    // Add all ancestors first
                    for ancestor in ancestors {
                        to_track.insert(ancestor);
                    }
                    to_track.insert(pr.head_branch.clone());
                    println!(
                        "  {} Will track with dependencies.\n",
                        Color::Green.paint("‚úì")
                    );
                } else {
                    skipped.insert(pr.head_branch.clone());
                    println!("  Skipped.\n");
                }
            } else {
                // Parent is not a discovered PR and not tracked
                println!(
                    "  {} Parent branch '{}' is not tracked and not an st PR.",
                    Color::Red.paint("‚ö†"),
                    pr.base_branch
                );
                println!(
                    "  Cannot track this branch without its parent being tracked first."
                );
                println!("  Skipping this PR.\n");
                skipped.insert(pr.head_branch.clone());
            }
        } else {
            // Parent is available, just ask about this branch
            let confirm = Confirm::new(&format!("Track '{}'?", pr.head_branch))
                .with_default(true)
                .prompt()?;

            if confirm {
                to_track.insert(pr.head_branch.clone());
                println!("  {} Will track.\n", Color::Green.paint("‚úì"));
            } else {
                skipped.insert(pr.head_branch.clone());
                println!("  Skipped.\n");
            }
        }
    }

    if to_track.is_empty() {
        println!("No branches selected for tracking.");
        return Ok(0);
    }

    println!(
        "\n{} Tracking {} branch(es)...\n",
        Color::Blue.paint("‚Üí"),
        to_track.len()
    );

    // Now actually track the branches in dependency order
    // We need to process them in order: parents before children
    let mut new_branches = 0;
    let mut tracked_this_run: HashSet<String> = HashSet::new();

    // Keep processing until we've handled all branches
    let mut remaining: Vec<String> = to_track.iter().cloned().collect();

    while !remaining.is_empty() {
        let mut made_progress = false;

        remaining.retain(|branch_name| {
            let pr = match all_prs_by_head.get(branch_name) {
                Some(pr) => pr,
                None => return false, // Remove from remaining
            };

            // Check if parent is ready (trunk, already tracked, or tracked this run)
            let parent_ready = pr.base_branch == trunk_name
                || already_tracked.contains(&pr.base_branch)
                || tracked_this_run.contains(&pr.base_branch);

            if !parent_ready {
                // Keep in remaining, process later
                return true;
            }

            // Parent is ready, track this branch
            // Check if branch exists locally, if not try to fetch
            let branch_exists_locally = repo.find_branch(branch_name, BranchType::Local).is_ok();
            if !branch_exists_locally {
                if let Err(e) = fetch_and_create_local_branch(branch_name) {
                    eprintln!(
                        "  {} Failed to fetch '{}': {}",
                        Color::Red.paint("‚úó"),
                        branch_name,
                        e
                    );
                    return false; // Remove from remaining
                }
            }

            // Get parent OID
            let parent_oid = repo
                .find_branch(&pr.base_branch, BranchType::Local)
                .ok()
                .and_then(|b| b.get().target())
                .map(|oid| oid.to_string())
                .unwrap_or_default();

            // Insert the branch
            if existing_tree
                .insert(&pr.base_branch, &parent_oid, branch_name)
                .is_ok()
            {
                // Set remote metadata
                if let Some(tracked) = existing_tree.get_mut(branch_name) {
                    tracked.remote = Some(RemoteMetadata::new(pr.number));
                }

                if pr.is_st_pr {
                    println!(
                        "  {} Tracked: {} ‚Üí {}",
                        Color::Green.paint("‚úì"),
                        Color::Green.paint(branch_name),
                        Color::Yellow.paint(&pr.base_branch)
                    );
                } else {
                    println!(
                        "  {} Tracked (non-st PR): {} ‚Üí {}",
                        Color::Green.paint("‚úì"),
                        Color::Yellow.paint(branch_name),
                        Color::Yellow.paint(&pr.base_branch)
                    );
                }
                new_branches += 1;
                tracked_this_run.insert(branch_name.clone());
                made_progress = true;
            } else {
                eprintln!(
                    "  {} Failed to insert '{}' into tree",
                    Color::Red.paint("‚úó"),
                    branch_name
                );
            }

            false // Remove from remaining (processed)
        });

        // Safety: avoid infinite loop if we can't make progress
        if !made_progress && !remaining.is_empty() {
            eprintln!(
                "\n{} Could not track {} branch(es) due to unresolved dependencies:",
                Color::Yellow.paint("‚ö†"),
                remaining.len()
            );
            for branch in &remaining {
                if let Some(pr) = all_prs_by_head.get(branch) {
                    eprintln!("  - {} (needs parent: {})", branch, pr.base_branch);
                }
            }
            break;
        }
    }

    println!(
        "\n{} Successfully tracked {} new branch(es).",
        Color::Green.paint("‚úì"),
        new_branches
    );

    Ok(new_branches)
}